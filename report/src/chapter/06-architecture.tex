\chapter{Architecture}

\minitoc

\subsubsection{Purpose}

The system is to be described in this chapter. This includes the main parts of the system, the architectural drivers, how they are connected together, and their collaboration. The architecture will be described through the 4+1 view model. The party members, or the stakeholders of the system, will have different concerns, so the 4+1 view model will help us describe the system for each of them, and make sure that all expectations are accounted for.  

\clearpage


\section{Architectural drivers}
The architectural drivers defines the project and its scope. 

\begin{itemize}
    \item Improving the efficiency in the chosen domain - The traditional web application system is to be improved efficiency-wise, so power users will be able to use less time on more tasks. (non-functional requirement)
    \item Proving the concept in general - Our solution should be applicable to more general problems than those described by the chosen domain. (business constraint)
    \item Minimum console functionality - The system's console should have capabilities on par with a traditional web application: Creating objects, editing objects, deleting objects, working with lists of objects.  (functional requirement)
    \item Added flexibility - The console should allow the user to perform tasks that are not possible with a web application of comparable complexity and development cost. (non-functional requirement)
    \item Console in a web context - The console should operate in a web browser environment. (technical constraint)
    \item Tolerate changes in requirements - We must use an approach that tolerates iterative changes to the demands from the customer. If new functionality is proposed and deemed likely to make the prototype more useful, it should be implemented asap. (business constraint)
    \item Delivery on time - The project must be finished on a fixed schedule. (business constraint) 
    \item Academically sound process - The project should be executed using methods that satisfy the academical context. (business constraint)
\end{itemize}


\section{Stakeholders}
The stakeholders and their concerns when it comes to the system.

\begin{itemize}
    \item Developer
    \begin{itemize}
        \item Solve the problem and deliver a system the customer will be satisfied with.
        \item Learn new technologies
        \item Get experience with project management
        \end{itemize}
    \item Customer
    \begin{itemize}
        \item Gets a working system, which satisfies the customers wants
        \item Get a usable report on the concept, which satisfies the customers wants
    \end{itemize}
    \item End user
    \begin{itemize}
        \item Improve efficiency
        \item Easy to use after some training
    \end{itemize}
\end{itemize}



\section{4+1 view model}
The 4+1 view model\cite{41viewmodel}. Here the views will be described, and how they will look in our architecture. 

\subsection{Logical View}
Describes the functionality in the system from the end users perspective.The end users will mainly be power users, wanting to perform object editing tasks efficiently. This view will be described through class, communication and sequence diagram.

\begin{figure}[h]
\centering
\includegraphics[width=6in]{image/clientClassDiagram.png}
\caption{Client Class Diagram}
\label{figure:clientClassDiagram}
\end{figure}

Figure~\ref{figure:clientClassDiagram} The client class diagram gives an overview of the class structure of system, and how they collaborate. We can see that the client consists of two separate views, a GUI and a Shell, which is split by a splitpane so the user can se bouth a GUI interface and the commandline interface. These two views can make changes to the library objects, and get reflected back to the other view. The library objects consists of a library filed with books. The changes done to a book is delivered to other clients and the server through PubNub. 

% \begin{wrapfigure}{r}{0.4\textwidth}
% \vspace{-60pt}
%   \begin{center}
%     \includegraphics[width=0.48\textwidth]{image/serverClassDiagram.png}
%   \end{center}
%   \vspace{-60pt}
%   \caption{Client Class Diagram}
%   \vspace{-60pt}
%   \label{figure:serverClassDiagram}
% \end{wrapfigure}

\begin{figure}[h]
\centering
\includegraphics[width=3in]{image/serverClassDiagram.png}
\caption{Client Class Diagram}
\label{figure:serverClassDiagram}
\end{figure}

Figure~\ref{figure:serverClassDiagram} The server class diagram shows how the REST api is set up, and the communication with the pubnub and db where the library information is stored.


\subsection{Process View}
Describes the dynamic aspect of the system, and explains how the different parts of the system will communicate at runtime. This is described with a activity diagram.

The user will ask for an object from the backend, this will be delivered to the client through the communication channel as a json object, the client will interpret this and the user can then edit it through the console, and send it back to the backend.


\subsection{Physical View}
Describes the system from the system engineer's perspective. And explains the physical connections between the software components. Described through a deployment diagram. 

\begin{figure}[h]
\centering
\includegraphics[width=5in]{image/DeploymentDiagram.png}
\caption{Deployment Diagram}
\label{figure:deploymentDiagram}
\end{figure}

Figure~\ref{figure:deploymentDiagram} The structure of the four different parts of the system.


\subsection{Development View}
Describes the system from the programmer's perspective. This will be described through how the different component parts are separated. Component and package diagrams will show this.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{image/ComponentDiagram.png}
\caption{Component Diagram}
\label{figure:componentDiagram}
\end{figure}

Figure~\ref{figure:componentDiagram} These components form a three layered structure, and communicate with each other through the neighboring layer.


%\subsubsection{Scenarios}
%Describes the system through a set of use cases/scenarios. These use cases/scenarios describes how the objects and processes work together.


\section{Tactics}
The architectural tactics are used to describe how different qualities of the system are achieved. 

\subsection{Modifiability}
Anticipate changes:

Probable changes should be anticipated, and accounted for, so extending the system with new functionality should be possible. This is important since we are dealing with a prototype/proof of concept system. So the customer might change the direction we are going in through out the project, this will lead to changes, and the architecture should be able to bend after these new inputs. 

This can be handled with a well defined functionality map, so that the expected system functionalities are accounted for when the system is constructed. 


\section{Architectural patterns}
The patterns can help solve different kinds of problems with know solutions on new problems.

\subsection{Multi-tier}

The architecture of the system will be of the multi-tier kind. This means that the presentation, application processing and data management functions will be separated logically. The application (console) will translate the task of the end user, and 

The console - Translate the task of the end user.
The logical tier - Will receive the translated task from the console, and fetch information from the data storage specified by the console, and set it back to the user.
The data storage - The last tier, and it will contain the information from the library.

figure of the 3 tiers. 

\subsection{MVC}

The client gui and console communication. Since the action made in the console should be reflected in the gui and vice versa, is it natural to use a model-view-controller pattern. The information in the model will then be separated from the view (the display) and the controller which performs an update on the model. 


\subsection{Rationale}


\section{Database}
\section{GUI}

